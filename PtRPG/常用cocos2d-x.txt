1.定义一个Scene

#ifndef __GAME_SCENE_H__
#define __GAME_SCENE_H__

#include "cocos2d.h"

USING_NS_CC;

class GameScene : public CCLayer
{
public:
	// Here's a difference. Method 'init' in cocos2d-x returns bool, instead of returning 'id' in cocos2d-iphone
	virtual bool init();
	
	// there's no 'id' in cpp, so we recommand to return the exactly class pointer
	static cocos2d::CCScene* scene();
	
	// implement the "static node()" method manually
	LAYER_NODE_FUNC(GameScene);
	
private:
	
};

#endif // __GAME_SCENE_H__

#include "GameScene.h"

USING_NS_CC;

CCScene* GameScene::scene()
{
	// 'scene' is an autorelease object
	CCScene *scene = CCScene::node();
	
	// 'layer' is an autorelease object
	GameScene *layer = GameScene::node();
	
	// add layer as a child to scene
	scene->addChild(layer);
	
	// return the scene
	return scene;
}

// on "init" you need to initialize your instance
bool GameScene::init()
{
	//////////////////////////////
	// 1. super init first
	if ( !CCLayer::init() )
	{
		return false;
	}
	
	CCSize winSize = CCDirector::sharedDirector()->getWinSize();
	
	return true;
}


2. 字符串的使用(NSString)
(1)
const char * getString()
{
	CCString *pRet = new CCString();
	pRet->autorelease();

	pRet->m_sString = XXXXX;
	
	return pRet->m_sString.c_str();
}


(2)
std::string mapName;
CCLOG("[%s]",mapName.c_str());

.h中声明
std::string * m_pFontName;
构造
, m_pFontName(NULL)
希构
CC_SAFE_DELETE(m_pFontName);
赋值
CC_SAFE_DELETE(m_pFontName);
m_pFontName = new std::string(fontName);




3. 格式刷(stringWithFormat)
char pTempMap[32] = {0};
sprintf(pTempMap,"%s.tmx",mapName.c_str());


4. CCMutableArray
CCMutableArray<CCSpriteFrame*> *walkRightFrames = new CCMutableArray<CCSpriteFrame*>();


5.CCARRAY_FOREACH使用
(1)
CCArray::arrayWithCapacity(10);

CCObject    * pObject;
CCARRAY_FOREACH(_RemoteplayerArray, pObject)
{
	PtCharacter * pCharacter = (PtCharacter*)pObject;
	if(pCharacter && pCharacter->_spriteSheet->getIsVisible())
	{
		//NViewDistance * pViewDistance = (NViewDistance*)[_ViewDistanceArray objectForKey:pCharacter.ItemID];
		//pViewDistance->getPosition() = pCharacter->_characterSprite->getPosition();
	}
}

(2)
CCNode   * child;
CCArray  * pArray  = menu->getChildren();
CCObject * pObject = NULL;
CCARRAY_FOREACH(pArray, pObject)
{
	if(pObject == NULL)
		break;

	child = (CCNode*)pObject;
}


6. win32内存检测工具Visual Leak Detector , CRT

7. 相反的动作 actionBy->reverse();

8. 相同的动作第二次使用，actionTo0->copy()->autorelease()

9. 动作Sequence ： CCSequence::actions(actionBy, actionByBack, NULL)

10. 重复动作: CCRepeatForever::actionWithAction(actionUp)

11. Iterator使用
CCMutableArray<CCObject *>::CCMutableArrayIterator it;
for(it = m_paddles->begin(); it != m_paddles->end(); it++)
	{
		paddle = (Paddle*)(*it);

		if(!paddle)
			break;
	}


12. CCLayerMultiplex与switchTo使用
CCLayer* pLayer1 = new MenuLayer1();
CCLayer* pLayer2 = new MenuLayer2();
CCLayer* pLayer3 = new MenuLayer3();
CCLayer* pLayer4 = new MenuLayer4();

CCLayerMultiplex* layer = CCLayerMultiplex::layerWithLayers(pLayer1, pLayer2, pLayer3, pLayer4, NULL);
addChild(layer, 0);

((CCLayerMultiplex*)m_pParent)->switchTo(0);


13. 添加触摸
setIsTouchEnabled( true );

void Parallax2::registerWithTouchDispatcher()
{
    CCTouchDispatcher::sharedDispatcher()->addTargetedDelegate(this, 0, true);
}

bool Parallax2::ccTouchBegan(CCTouch* touch, CCEvent* event)
{
	return true;
}

void Parallax2::ccTouchEnded(CCTouch* touch, CCEvent* event)
{
}

void Parallax2::ccTouchCancelled(CCTouch* touch, CCEvent* event)
{
}

void Parallax2::ccTouchMoved(CCTouch* touch, CCEvent* event)
{
	CCPoint touchLocation = touch->locationInView( touch->view() );	
	CCPoint prevLocation = touch->previousLocationInView( touch->view() );	

	touchLocation = CCDirector::sharedDirector()->convertToGL( touchLocation );
	prevLocation = CCDirector::sharedDirector()->convertToGL( prevLocation );

	CCPoint diff = ccpSub(touchLocation,prevLocation);
	
	CCNode* node = getChildByTag(kTagNode);
	CCPoint currentPos = node->getPosition();
	node->setPosition( ccpAdd(currentPos, diff) );
}

14. 反锯齿
child->getTexture()->setAntiAliasTexParameters();

15. Accelerometer
setIsAccelerometerEnabled(true);

void AccelerometerTest::didAccelerate(CCAcceleration* pAccelerationValue)
{

}

16. 












西蒙iphone-OpenGL ES

1. glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  清除了屏幕







